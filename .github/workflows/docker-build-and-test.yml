name: Docker Build & Test

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  docker-build-and-test:
    name: Build Docker Image and Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: |
          docker build -f musicdl.Dockerfile -t musicdl:test .

      - name: Set image tag variable
        run: echo "IMAGE_TAG=musicdl:test" >> $GITHUB_ENV

      - name: Smoke Test 1 - Directory structure
        run: |
          echo "Testing directory structure..."
          docker run --rm --entrypoint test "$IMAGE_TAG" -d /scripts && echo "✓ /scripts exists" || (echo "✗ /scripts missing" && exit 1)
          docker run --rm --entrypoint test "$IMAGE_TAG" -d /download && echo "✓ /download exists" || (echo "✗ /download missing" && exit 1)
          docker run --rm --entrypoint test "$IMAGE_TAG" -d /var/lib/musicdl/plans && echo "✓ /var/lib/musicdl/plans exists" || (echo "✗ /var/lib/musicdl/plans missing" && exit 1)
          docker run --rm --entrypoint test "$IMAGE_TAG" -d /var/lib/musicdl/logs && echo "✓ /var/lib/musicdl/logs exists" || (echo "✗ /var/lib/musicdl/logs missing" && exit 1)

      - name: Smoke Test 2 - File permissions
        run: |
          echo "Testing file permissions..."
          docker run --rm --entrypoint test "$IMAGE_TAG" -x /scripts/entrypoint.sh && echo "✓ entrypoint.sh is executable" || (echo "✗ entrypoint.sh not executable" && exit 1)
          docker run --rm --entrypoint test "$IMAGE_TAG" -w /download && echo "✓ /download is writable" || (echo "✗ /download not writable" && exit 1)

      - name: Smoke Test 3 - System dependencies
        run: |
          echo "Testing system dependencies..."
          docker run --rm --entrypoint ffmpeg "$IMAGE_TAG" -version > /dev/null 2>&1 && echo "✓ ffmpeg is available" || (echo "✗ ffmpeg not found" && exit 1)

      - name: Smoke Test 4 - Go binary verification
        run: |
          echo "Testing Go binary..."
          # Check binary exists
          docker run --rm --entrypoint test "$IMAGE_TAG" -f /usr/local/bin/musicdl && echo "✓ Go binary exists" || (echo "✗ Go binary not found" && exit 1)
          # Check binary is executable
          docker run --rm --entrypoint test "$IMAGE_TAG" -x /usr/local/bin/musicdl && echo "✓ Go binary is executable" || (echo "✗ Go binary not executable" && exit 1)
          # Check binary responds to help
          docker run --rm --entrypoint /usr/local/bin/musicdl "$IMAGE_TAG" serve --help 2>&1 | grep -q "serve" && echo "✓ Go binary responds to help" || (echo "✗ Go binary does not respond correctly" && exit 1)

      - name: Functional Test - Control Platform API
        run: |
          echo "Testing control platform API..."
          set -e
          
          # Cleanup function to ensure container is always stopped and logs are captured
          cleanup() {
            if [ -n "$CONTAINER_ID" ]; then
              echo "=== Container Logs ==="
              docker logs "$CONTAINER_ID" 2>&1 || true
              echo "====================="
              docker stop "$CONTAINER_ID" 2>/dev/null || true
              docker rm "$CONTAINER_ID" 2>/dev/null || true
            fi
          }
          trap cleanup EXIT
          
          # Start container in background with port mapping
          CONTAINER_ID=$(docker run -d -p 8080:8080 "$IMAGE_TAG")
          if [ -z "$CONTAINER_ID" ]; then
            echo "✗ Failed to start container"
            exit 1
          fi
          echo "Container started: $CONTAINER_ID"
          
          # Wait for server to be ready (with timeout and retry)
          MAX_WAIT=30
          WAITED=0
          while [ $WAITED -lt $MAX_WAIT ]; do
            if curl -sf http://localhost:8080/api/health > /dev/null 2>&1; then
              echo "✓ Server is ready"
              break
            fi
            sleep 1
            WAITED=$((WAITED + 1))
          done
          
          if [ $WAITED -ge $MAX_WAIT ]; then
            echo "✗ Server did not become ready within ${MAX_WAIT}s"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          
          # Test health endpoint (should return JSON)
          echo "Testing health endpoint..."
          HEALTH_RESPONSE=$(curl -sf http://localhost:8080/api/health 2>&1) || HEALTH_CURL_EXIT=$?
          if [ -n "$HEALTH_CURL_EXIT" ]; then
            echo "✗ Health endpoint curl failed with exit code: $HEALTH_CURL_EXIT"
            echo "Response: $HEALTH_RESPONSE"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          if [ -z "$HEALTH_RESPONSE" ]; then
            echo "✗ Health endpoint returned empty response"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          
          # Verify JSON format and status
          if ! echo "$HEALTH_RESPONSE" | grep -q '"status"'; then
            echo "✗ Health endpoint response is not valid JSON"
            echo "Response: $HEALTH_RESPONSE"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          echo "✓ Health endpoint returns valid JSON"
          
          # Test status endpoint with detailed error reporting
          echo "Testing status endpoint..."
          STATUS_RESPONSE=$(curl -sf http://localhost:8080/api/status 2>&1) || STATUS_CURL_EXIT=$?
          if [ -n "$STATUS_CURL_EXIT" ]; then
            echo "✗ Status endpoint curl failed with exit code: $STATUS_CURL_EXIT"
            echo "Curl output: $STATUS_RESPONSE"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            echo "=== Container Status ==="
            docker ps -a --filter "id=$CONTAINER_ID" || true
            echo "========================="
            exit 1
          fi
          if [ -z "$STATUS_RESPONSE" ]; then
            echo "✗ Status endpoint returned empty response"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          
          # Verify status JSON format
          if ! echo "$STATUS_RESPONSE" | grep -q '"state"'; then
            echo "✗ Status endpoint response is not valid JSON"
            echo "Response: $STATUS_RESPONSE"
            echo "=== Container Logs ==="
            docker logs "$CONTAINER_ID" 2>&1
            echo "====================="
            exit 1
          fi
          echo "✓ Status endpoint returns valid JSON"
          
          # Cleanup (trap will also handle this, but explicit is good)
          echo "✓ All tests passed"
