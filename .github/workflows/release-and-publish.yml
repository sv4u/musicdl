name: Release & Publish

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Type of release"
        required: true
        type: choice
        options:
          - major
          - minor
          - hotfix/patch
      dry_run:
        description: "Run in dry-run mode (no releases or commits)"
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

jobs:
  release-and-publish:
    name: Release and Publish
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify branch and working directory
        run: |
          # Check if we're on main branch
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "[X] Error: This workflow must be run from the 'main' branch"
            echo "Current branch: $CURRENT_BRANCH"
            exit 1
          fi

          # Check if working directory is clean
          if ! git diff-index --quiet HEAD --; then
            echo "[X] Error: Working directory is not clean. Please commit or stash changes."
            git status
            exit 1
          fi

          # Check if branch is up-to-date with remote
          git fetch origin main
          LOCAL=$(git rev-parse HEAD)
          REMOTE=$(git rev-parse origin/main)
          if [ "$LOCAL" != "$REMOTE" ]; then
            echo "[X] Error: Local branch is not up-to-date with remote. Please pull latest changes."
            echo "Local: $LOCAL"
            echo "Remote: $REMOTE"
            exit 1
          fi

          echo "[OK] Branch verification passed"

      - name: Get current version
        id: current-version
        run: |
          # Fetch all tags to ensure we have latest
          git fetch --tags

          # Get latest tag, preferring v-prefixed tags
          ORIGINAL_TAG=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || \
                         git describe --tags --abbrev=0 2>/dev/null || \
                         echo "v0.0.0")

          # Store original tag for git operations (must exist in repository)
          # Remove 'v' prefix if present for version calculation
          VERSION=${ORIGINAL_TAG#v}

          # Normalize version format: convert X.Y to X.Y.0 for backward compatibility
          # This normalized version is used for calculations, but git operations use original tag
          NORMALIZED_TAG="$ORIGINAL_TAG"
          if echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+$'; then
            # Two-part version (X.Y) - add .0 patch component
            VERSION="${VERSION}.0"
            NORMALIZED_TAG="v${VERSION}"
            echo "[i] Normalized legacy tag format: $ORIGINAL_TAG -> $NORMALIZED_TAG (for version calculation)"
            echo "[i] Git operations will use original tag: $ORIGINAL_TAG"
          fi

          echo "Original tag (for git operations): $ORIGINAL_TAG"
          echo "Normalized tag (for version calculation): $NORMALIZED_TAG"
          echo "Current version: $VERSION"
          echo "original_tag=$ORIGINAL_TAG" >> $GITHUB_OUTPUT
          echo "tag=$NORMALIZED_TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Calculate next version
        id: next-version
        run: |
          ORIGINAL_TAG="${{ steps.current-version.outputs.original_tag }}"
          NORMALIZED_TAG="${{ steps.current-version.outputs.tag }}"
          CURRENT_VERSION="${{ steps.current-version.outputs.version }}"
          RELEASE_TYPE="${{ inputs.release_type }}"

          # For first release (no tags exist), always default to v0.0.1 regardless of release type
          # Check original tag to determine if this is the first release
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            NEXT_VERSION="0.0.1"
            NEXT_TAG="v0.0.1"
            echo "First release detected. Defaulting to v0.0.1 (release type '$RELEASE_TYPE' is ignored for first release)."
            echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
            echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Validate current version format (must be X.Y.Z, three-part semantic versioning)
          if ! echo "$CURRENT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "[X] Error: Invalid version format: $CURRENT_VERSION"
            echo "   Expected format: X.Y.Z (e.g., 1.1.0)"
            echo "   Original tag: $ORIGINAL_TAG"
            echo "   Normalized tag: $NORMALIZED_TAG"
            exit 1
          fi

          # Parse version components (three-part: MAJOR.MINOR.PATCH)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Validate all components are non-empty
          if [ -z "$MAJOR" ] || [ -z "$MINOR" ] || [ -z "$PATCH" ]; then
            echo "[X] Error: Invalid version format: $CURRENT_VERSION"
            echo "   Version must have three components: MAJOR.MINOR.PATCH"
            echo "   Parsed components: MAJOR='$MAJOR' MINOR='$MINOR' PATCH='$PATCH'"
            exit 1
          fi

          # Calculate next version based on release type (three-part semantic versioning)
          # Use 10# prefix to force decimal interpretation and prevent octal issues with leading zeros
          case "$RELEASE_TYPE" in
            major)
              MAJOR=$((10#$MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((10#$MINOR + 1))
              PATCH=0
              ;;
            "hotfix/patch")
              PATCH=$((10#$PATCH + 1))
              ;;
            *)
              echo "[X] Error: Invalid release type: $RELEASE_TYPE"
              exit 1
              ;;
          esac

          NEXT_VERSION="$MAJOR.$MINOR.$PATCH"
          NEXT_TAG="v$NEXT_VERSION"

          # Validate calculated version format
          if ! echo "$NEXT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "[X] Error: Calculated version format is invalid: $NEXT_VERSION"
            exit 1
          fi

          # Validate tag name format (Git restrictions: no spaces, no special chars except - and .)
          # Tag names must be valid ref names: cannot contain spaces, control chars, or certain special chars
          if ! echo "$NEXT_TAG" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "[X] Error: Invalid tag name format: $NEXT_TAG"
            echo "   Tag names must match pattern: vX.Y.Z (e.g., v1.1.0)"
            exit 1
          fi

          # Validate tag name length (Git limit is 255 characters for ref names)
          TAG_NAME_LENGTH=$(printf '%s' "$NEXT_TAG" | wc -c)
          MAX_TAG_NAME_LENGTH=255
          if [ "$TAG_NAME_LENGTH" -gt "$MAX_TAG_NAME_LENGTH" ]; then
            echo "[X] Error: Tag name exceeds maximum length ($TAG_NAME_LENGTH > $MAX_TAG_NAME_LENGTH characters)"
            exit 1
          fi

          echo "Release type: $RELEASE_TYPE"
          echo "Current version: $CURRENT_VERSION"
          echo "Next version: $NEXT_VERSION"
          echo "Next tag: $NEXT_TAG"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT

      - name: Check commit range
        id: commit-range
        run: |
          ORIGINAL_TAG="${{ steps.current-version.outputs.original_tag }}"
          NORMALIZED_TAG="${{ steps.current-version.outputs.tag }}"

          # If no tags exist (ORIGINAL_TAG is v0.0.0), count all commits
          # Otherwise, count commits since the latest tag (use original tag for git operations)
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            COMMIT_COUNT=$(git rev-list --count HEAD 2>/dev/null || echo "0")
            echo "No existing tags found. Counting all commits for first release."
          else
            COMMIT_COUNT=$(git rev-list --count ${ORIGINAL_TAG}..HEAD 2>/dev/null || echo "0")
          fi

          if [ "$COMMIT_COUNT" -eq 0 ]; then
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "[!] Warning: No commits to release (dry-run mode, continuing)"
              if [ "$ORIGINAL_TAG" != "v0.0.0" ]; then
                echo "   No commits since $ORIGINAL_TAG"
              else
                echo "   Repository has no commits"
              fi
              echo "   In a real release, this would prevent the release from being created."
              echo "   This prevents duplicate releases. Please ensure there are new commits."
              echo "validation_would_fail=true" >> $GITHUB_OUTPUT
            else
              echo "[X] Error: No commits to release"
              if [ "$ORIGINAL_TAG" != "v0.0.0" ]; then
                echo "   No commits since $ORIGINAL_TAG"
              else
                echo "   Repository has no commits"
              fi
              echo "   This prevents duplicate releases. Please ensure there are new commits."
              exit 1
            fi
          else
            echo "validation_would_fail=false" >> $GITHUB_OUTPUT
          fi

          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            echo "Commit count (all commits): $COMMIT_COUNT"
          else
            echo "Commit count since $ORIGINAL_TAG: $COMMIT_COUNT"
          fi
          echo "count=$COMMIT_COUNT" >> $GITHUB_OUTPUT

          # Get commit types for preview (only from commits that match GitHub CLI's changelog filters)
          # Supports both scoped and unscoped Conventional Commits (e.g., feat: and feat(scope):)
          # Use original tag for git operations
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            COMMIT_TYPES=$(git log --format="%s" HEAD | \
              grep -E '^(feat|fix|docs|refactor|perf|ci|chore)(\([^)]+\))?!?:' | \
              grep -vE '^docs(\([^)]+\))?!?:.*README' | \
              grep -vE '^test(\([^)]+\))?!?:' | \
              sed -E 's/^([a-z]+)(\([^)]+\))?!?:.*/\1/' | \
              sort -u | \
              tr '\n' ', ' | \
              sed 's/,$//')
          else
            COMMIT_TYPES=$(git log --format="%s" ${ORIGINAL_TAG}..HEAD | \
              grep -E '^(feat|fix|docs|refactor|perf|ci|chore)(\([^)]+\))?!?:' | \
              grep -vE '^docs(\([^)]+\))?!?:.*README' | \
              grep -vE '^test(\([^)]+\))?!?:' | \
              sed -E 's/^([a-z]+)(\([^)]+\))?!?:.*/\1/' | \
              sort -u | \
              tr '\n' ', ' | \
              sed 's/,$//')
          fi

          # Handle empty commit types (no Conventional Commits found)
          if [ -z "$COMMIT_TYPES" ]; then
            COMMIT_TYPES="(none - no Conventional Commits found)"
          fi
          echo "commit_types=$COMMIT_TYPES" >> $GITHUB_OUTPUT

      - name: Preview version and confirm
        if: ${{ inputs.dry_run != 'true' }}
        run: |
          ORIGINAL_TAG="${{ steps.current-version.outputs.original_tag }}"
          NORMALIZED_TAG="${{ steps.current-version.outputs.tag }}"
          IS_FIRST_RELEASE=false
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            IS_FIRST_RELEASE=true
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "[PKG] RELEASE PREVIEW"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          RELEASE_TYPE_DISPLAY="${{ inputs.release_type }}"
          echo "Release Type:    $RELEASE_TYPE_DISPLAY"
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Current Version: (none - first release)"
          else
            echo "Current Version: $NORMALIZED_TAG"
          fi
          echo "Next Version:    ${{ steps.next-version.outputs.tag }}"
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Commits:         ${{ steps.commit-range.outputs.count }} commits (all commits)"
          else
            echo "Commits:         ${{ steps.commit-range.outputs.count }} commits since last release"
          fi
          echo "Commit Types:    ${{ steps.commit-range.outputs.commit_types }}"
          echo ""
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Compare View:    (Initial release - no previous version to compare)"
          else
            echo "Compare View:    https://github.com/${{ github.repository }}/compare/$ORIGINAL_TAG...HEAD"
          fi
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "[!] This will:"
          echo "   1. Create and push tag: ${{ steps.next-version.outputs.tag }}"
          echo "   2. Generate changelog from commits"
          echo "   3. Create and publish GitHub release"
          echo "   4. Build Docker image"
          echo "   5. Publish Docker image to GHCR"
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "[||] Waiting 10 seconds before proceeding..."
          echo "   (This workflow will continue automatically)"
          sleep 10

      - name: Display dry-run preview
        if: ${{ inputs.dry_run == 'true' }}
        run: |
          ORIGINAL_TAG="${{ steps.current-version.outputs.original_tag }}"
          NORMALIZED_TAG="${{ steps.current-version.outputs.tag }}"
          IS_FIRST_RELEASE=false
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            IS_FIRST_RELEASE=true
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "[?] DRY-RUN MODE - PREVIEW ONLY"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          RELEASE_TYPE_DISPLAY="${{ inputs.release_type }}"
          echo "Release Type:    $RELEASE_TYPE_DISPLAY"
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Current Version: (none - first release)"
          else
            echo "Current Version: $NORMALIZED_TAG"
          fi
          echo "Next Version:    ${{ steps.next-version.outputs.tag }}"
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Commits:         ${{ steps.commit-range.outputs.count }} commits (all commits)"
          else
            echo "Commits:         ${{ steps.commit-range.outputs.count }} commits since last release"
          fi
          echo "Commit Types:    ${{ steps.commit-range.outputs.commit_types }}"
          echo ""
          if [ "$IS_FIRST_RELEASE" = "true" ]; then
            echo "Compare View:    (Initial release - no previous version to compare)"
          else
            echo "Compare View:    https://github.com/${{ github.repository }}/compare/$ORIGINAL_TAG...HEAD"
          fi
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "[i] In dry-run mode, no tags, releases, or images will be created."

      - name: Check if tag already exists
        id: tag-check
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"
          DRY_RUN="${{ inputs.dry_run }}"

          # Check local tag
          if git rev-parse --verify "$NEXT_TAG" >/dev/null 2>&1; then
            if [ "$DRY_RUN" = "true" ]; then
              echo "[!] Warning: Tag $NEXT_TAG already exists locally (dry-run mode, continuing)"
            else
              echo "[X] Error: Tag $NEXT_TAG already exists locally!"
              exit 1
            fi
          fi

          # Check remote tag (use exact ref matching)
          if git ls-remote --tags origin "refs/tags/$NEXT_TAG" | grep -q "refs/tags/$NEXT_TAG"; then
            if [ "$DRY_RUN" = "true" ]; then
              echo "[!] Warning: Tag $NEXT_TAG already exists on remote (dry-run mode, continuing)"
            else
              echo "[X] Error: Tag $NEXT_TAG already exists on remote!"
              exit 1
            fi
          fi

          if [ "$DRY_RUN" != "true" ]; then
            echo "[OK] Tag $NEXT_TAG is available"
          else
            echo "[i] Tag $NEXT_TAG check completed (dry-run mode)"
          fi

      - name: Dry-run completion summary
        if: ${{ inputs.dry_run == 'true' }}
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "[✓] DRY-RUN COMPLETED SUCCESSFULLY"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Validation Summary:"
          echo "  ✓ Version calculation validated"
          echo "  ✓ Commit range checked"
          echo "  ✓ Tag availability verified"
          echo ""
          if [ "${{ steps.commit-range.outputs.validation_would_fail }}" = "true" ]; then
            echo "  ⚠ Commit validation: Would fail in real release (no commits to release)"
          else
            echo "  ✓ Commit validation passed"
          fi
          echo ""
          echo "In a real release, this workflow would:"
          echo "  1. Create and push tag: ${{ steps.next-version.outputs.tag }}"
          echo "  2. Create GitHub release with auto-generated changelog"
          echo "  3. Build Docker image"
          echo "  4. Publish Docker image to GHCR"
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

      - name: Create and push tag
        if: ${{ inputs.dry_run != 'true' }}
        id: create-tag
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"
          RELEASE_TYPE="${{ inputs.release_type }}"
          COMMIT_COUNT="${{ steps.commit-range.outputs.count }}"
          ORIGINAL_TAG="${{ steps.current-version.outputs.original_tag }}"
          NORMALIZED_TAG="${{ steps.current-version.outputs.tag }}"
          CURRENT_DATE=$(date +%Y-%m-%d)

          # Create tag message with proper newlines using printf
          # Handle first release differently (no previous tag to reference)
          # Use normalized tag for display in message (shows semantic version)
          if [ "$ORIGINAL_TAG" = "v0.0.0" ]; then
            # First release - no previous tag to reference
            TAG_MESSAGE=$(printf "Release %s (%s) - %s\n\nAutomated release via GitHub Actions workflow.\nInitial release. Includes %s commits." "$NEXT_TAG" "$RELEASE_TYPE" "$CURRENT_DATE" "$COMMIT_COUNT")
          else
            # Subsequent release - reference previous normalized tag for display
            TAG_MESSAGE=$(printf "Release %s (%s) - %s\n\nAutomated release via GitHub Actions workflow.\nIncludes %s commits since %s." "$NEXT_TAG" "$RELEASE_TYPE" "$CURRENT_DATE" "$COMMIT_COUNT" "$NORMALIZED_TAG")
          fi

          # Validate tag message length (Git limit is ~64KB, use conservative 60KB)
          TAG_MESSAGE_LENGTH=$(printf '%s' "$TAG_MESSAGE" | wc -c)
          MAX_TAG_MESSAGE_LENGTH=61440  # 60KB in bytes
          if [ "$TAG_MESSAGE_LENGTH" -gt "$MAX_TAG_MESSAGE_LENGTH" ]; then
            echo "[X] Error: Tag message exceeds maximum length ($TAG_MESSAGE_LENGTH > $MAX_TAG_MESSAGE_LENGTH bytes)"
            echo "   This may occur with extremely large commit counts. Consider splitting the release."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          echo "Creating tag: $NEXT_TAG"
          git tag -a "$NEXT_TAG" -m "$TAG_MESSAGE"

          echo "Pushing tag to remote..."
          git push origin "$NEXT_TAG"

          echo "[OK] Tag $NEXT_TAG created and pushed successfully"

      - name: Verify GitHub CLI
        if: ${{ inputs.dry_run != 'true' }}
        run: |
          gh --version

      - name: Check if release already exists
        if: ${{ inputs.dry_run != 'true' }}
        id: check-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"
          if gh release view "$NEXT_TAG" >/dev/null 2>&1; then
            echo "[X] Error: Release $NEXT_TAG already exists"
            echo "   To update the release, delete it first or use a different version"
            exit 1
          fi

      - name: Set up Docker Buildx
        if: ${{ inputs.dry_run != 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: ${{ inputs.dry_run != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker image tags
        if: ${{ inputs.dry_run != 'true' }}
        id: docker-tags
        run: |
          VERSION_TAG="${{ steps.next-version.outputs.tag }}"
          VERSION_TAG_FULL="ghcr.io/sv4u/musicdl:${VERSION_TAG}"
          echo "version_tag=${VERSION_TAG_FULL}" >> $GITHUB_OUTPUT
          echo "tags_list=${VERSION_TAG_FULL},ghcr.io/sv4u/musicdl:latest" >> $GITHUB_OUTPUT

      - name: Generate build timestamp
        if: ${{ inputs.dry_run != 'true' }}
        id: build-timestamp
        run: |
          BUILD_TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "timestamp=${BUILD_TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        if: ${{ inputs.dry_run != 'true' }}
        id: docker-build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./musicdl.Dockerfile
          tags: ${{ steps.docker-tags.outputs.tags_list }}
          push: true
          labels: |
            org.opencontainers.image.source=https://github.com/sv4u/musicdl
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.build-timestamp.outputs.timestamp }}
            org.opencontainers.image.version=${{ steps.next-version.outputs.tag }}

      - name: Create GitHub release with changelog
        if: ${{ inputs.dry_run != 'true' }}
        id: create-release
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"
          RELEASE_TITLE="Release $NEXT_TAG"

          if [ -z "${{ secrets.RELEASE_PAT }}" ]; then
            echo "[!] Warning: RELEASE_PAT secret not configured."
            echo "   Using GITHUB_TOKEN, but release events will NOT trigger other workflows."
            echo "   To enable automatic SBOM attachment, configure RELEASE_PAT secret."
            echo "   See workflow documentation for PAT setup instructions."
          fi

          # Create release with auto-generated changelog
          if gh release create "$NEXT_TAG" \
            --title "$RELEASE_TITLE" \
            --generate-notes; then
            echo "[OK] Release $NEXT_TAG created successfully"
          else
            RELEASE_EXIT=$?
            echo "[X] Error: Failed to create release (exit code: $RELEASE_EXIT)"
            echo "   This may occur if:"
            echo "   - Release already exists"
            echo "   - GitHub API rate limit exceeded"
            echo "   - Network connectivity issues"
            echo "   - Invalid or expired token"
            exit $RELEASE_EXIT
          fi

      - name: Verify release was created
        if: ${{ inputs.dry_run != 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"

          # Check if GitHub CLI is available
          if command -v gh &> /dev/null; then
            echo "Verifying release using GitHub CLI..."
            if gh release view "$NEXT_TAG" --json tagName,body >/dev/null 2>&1; then
              RELEASE_BODY=$(gh release view "$NEXT_TAG" --json body --jq '.body')

              echo "[OK] Release verified:"
              echo "   Tag: $NEXT_TAG"
              echo "   Has changelog: $([ -n "$RELEASE_BODY" ] && echo "yes" || echo "no")"
            else
              echo "[!] Could not verify release via GitHub CLI"
            fi
          else
            # Fallback to API check
            echo "Verifying release using GitHub API..."
            API_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$NEXT_TAG" || echo "")

            if [ -n "$API_RESPONSE" ] && echo "$API_RESPONSE" | grep -q '"tag_name"'; then
              echo "[OK] Release verified via API"
            else
              echo "[!] Could not verify release via API (may still be processing)"
            fi
          fi

      - name: Rollback tag and release on failure
        if: ${{ inputs.dry_run != 'true' && (failure() || steps.create-release.outcome == 'failure' || steps.docker-build.outcome == 'failure') }}
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}
        run: |
          NEXT_TAG="${{ steps.next-version.outputs.tag }}"

          echo "[X] Release or Docker publish failed. Rolling back tag and release..."

          # Delete GitHub release if it was created
          if [ "${{ steps.create-release.outcome }}" = "success" ]; then
            echo "Deleting GitHub release: $NEXT_TAG"
            if gh release delete "$NEXT_TAG" --yes 2>/dev/null; then
              echo "[OK] Deleted GitHub release: $NEXT_TAG"
            else
              echo "[!] Warning: Failed to delete GitHub release: $NEXT_TAG"
              echo "   Release may still exist. Manual cleanup may be required."
              echo "   To delete manually, run: gh release delete $NEXT_TAG --yes"
            fi
          fi

          # Delete local tag
          if git rev-parse --verify "$NEXT_TAG" >/dev/null 2>&1; then
            git tag -d "$NEXT_TAG"
            echo "[OK] Deleted local tag: $NEXT_TAG"
          fi

          # Delete remote tag (use exact ref matching)
          if git ls-remote --tags origin "refs/tags/$NEXT_TAG" | grep -q "refs/tags/$NEXT_TAG"; then
            if git push origin ":refs/tags/$NEXT_TAG" 2>&1; then
              echo "[OK] Deleted remote tag: $NEXT_TAG"
            else
              echo "[!] Warning: Failed to delete remote tag: $NEXT_TAG"
              echo "   Tag may still exist on remote. Manual cleanup may be required."
              echo "   To delete manually, run: git push origin :refs/tags/$NEXT_TAG"
            fi
          fi

          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "[<->] Tag and release rollback completed"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          exit 1

      - name: Verify Docker image was published
        if: ${{ inputs.dry_run != 'true' && steps.docker-build.outcome == 'success' }}
        run: |
          VERSION_TAG="${{ steps.next-version.outputs.tag }}"
          IMAGE_TAG="ghcr.io/sv4u/musicdl:${VERSION_TAG}"

          echo "Verifying Docker image was published..."
          echo "Image: $IMAGE_TAG"
          echo "Latest: ghcr.io/sv4u/musicdl:latest"
          echo ""
          echo "[OK] Docker image published successfully"

      - name: Display release summary
        if: ${{ inputs.dry_run != 'true' && steps.create-release.outcome == 'success' && steps.docker-build.outcome == 'success' }}
        run: |
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "[OK] RELEASE & PUBLISH COMPLETED SUCCESSFULLY"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo ""
          echo "Tag:     ${{ steps.next-version.outputs.tag }}"
          echo "Version: ${{ steps.next-version.outputs.version }}"
          echo "Commits: ${{ steps.commit-range.outputs.count }} commits included"
          echo ""
          echo "Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ steps.next-version.outputs.tag }}"
          echo ""
          echo "Docker Images:"
          echo "  - ghcr.io/sv4u/musicdl:${{ steps.next-version.outputs.tag }}"
          echo "  - ghcr.io/sv4u/musicdl:latest"
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
